import gradio as gr
import sqlite3
import numpy as np
import google.generativeai as genai
from sklearn.metrics.pairwise import cosine_similarity
from deep_translator import GoogleTranslator
import csv
import os


import streamlit as st
import pandas as pd
import folium
from streamlit_folium import folium_static
import plotly.express as px
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os

# Language translations
    
ADMIN_KEY = "1234"

    # Load Data
@st.cache_data
def load_data():
        return pd.read_csv(r"E:\\Vineeth_Final (1)\\Vineeth_Final\\Vineeth_Copy\\Vineeth_Copy\\health_alert_bangalore_v2 (1).csv")

df = load_data()

    # Streamlit UI
st.sidebar.title("‚öôÔ∏è Settings")
user_type = st.sidebar.radio("Select User Type:", ["User", "Admin" , "Chat bots"])

if user_type == "User":
    translations = {
        "English": {
            "title": "üåç Bangalore Health Alert System",
            "subtitle": "Stay updated on disease outbreaks in Bangalore!",
            "upload_text": "Upload Health Alert Dataset (CSV)",
            "select_location": "Select your current location:",
            "subscribe_header": "üì© Subscribe for Outbreak Alerts",
            "email_input": "Enter your email to receive health alerts:",
            "subscribe_button": "Subscribe",
            "subscription_success": "‚úÖ Subscription successful! You will receive alerts for severe outbreaks in your area.",
            "email_warning": "‚ö†Ô∏è Please enter a valid email address.",
            "health_alert": "üö® Health Alert in",
            "common_disease": "Most Common Disease:",
            "precautions_header": "üõ°Ô∏è Precautionary Measures",
            "trend_analysis": "üìä Disease Trend Analysis",
            "no_outbreak": "‚úÖ No disease outbreaks reported in your area.",
            "email_sent": "üìß Alert sent to",
            "email_failed": "‚ùå Failed to send email:",
            "checking_alerts": "Checking for alerts...",
            "high_risk_alert": "‚ö†Ô∏è High-Risk Alert!",
            "high_risk_message": "is experiencing a severe outbreak of",
            "take_precautions": "Take precautions!"
        },
        "‡≤ï‡≤®‡≥ç‡≤®‡≤°": {  # Kannada
            "title": "üåç ‡≤¨‡≥Ü‡≤Ç‡≤ó‡≤≥‡≥Ç‡≤∞‡≥Å ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü ‡≤µ‡≥ç‡≤Ø‡≤µ‡≤∏‡≥ç‡≤•‡≥Ü",
            "subtitle": "‡≤¨‡≥Ü‡≤Ç‡≤ó‡≤≥‡≥Ç‡≤∞‡≤ø‡≤®‡≤≤‡≥ç‡≤≤‡≤ø ‡≤∞‡≥ã‡≤ó ‡≤π‡≤∞‡≤°‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü‡≤Ø ‡≤¨‡≤ó‡≥ç‡≤ó‡≥Ü ‡≤®‡≤µ‡≥Ä‡≤ï‡≤∞‡≤ø‡≤∏‡≤ø‡≤¶ ‡≤Æ‡≤æ‡≤π‡≤ø‡≤§‡≤ø‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤°‡≥Ü‡≤Ø‡≤ø‡≤∞‡≤ø!",
            "upload_text": "‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü ‡≤°‡≥á‡≤ü‡≤æ‡≤∏‡≥Ü‡≤ü‡≥ç ‡≤Ö‡≤™‡≥ç‚Äå‡≤≤‡≥ã‡≤°‡≥ç ‡≤Æ‡≤æ‡≤°‡≤ø (CSV)",
            "select_location": "‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≥ç‡≤∞‡≤∏‡≥ç‡≤§‡≥Å‡≤§ ‡≤∏‡≥ç‡≤•‡≤≥‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤Ü‡≤Ø‡≥ç‡≤ï‡≥Ü‡≤Æ‡≤æ‡≤°‡≤ø:",
            "subscribe_header": "üì© ‡≤π‡≤∞‡≤°‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü‡≤ó‡≤≥‡≤ø‡≤ó‡≥Ü ‡≤ö‡≤Ç‡≤¶‡≤æ‡≤¶‡≤æ‡≤∞‡≤∞‡≤æ‡≤ó‡≤ø",
            "email_input": "‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤°‡≥Ü‡≤Ø‡≤≤‡≥Å ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤á‡≤Æ‡≥á‡≤≤‡≥ç ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø:",
            "subscribe_button": "‡≤ö‡≤Ç‡≤¶‡≤æ‡≤¶‡≤æ‡≤∞‡≤∞‡≤æ‡≤ó‡≤ø",
            "subscription_success": "‚úÖ ‡≤ö‡≤Ç‡≤¶‡≤æ‡≤¶‡≤æ‡≤∞‡≤ø‡≤ï‡≥Ü ‡≤Ø‡≤∂‡≤∏‡≥ç‡≤µ‡≤ø‡≤Ø‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü! ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≥ç‡≤∞‡≤¶‡≥á‡≤∂‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞ ‡≤π‡≤∞‡≤°‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü‡≤ó‡≤≥ ‡≤¨‡≤ó‡≥ç‡≤ó‡≥Ü ‡≤®‡≥Ä‡≤µ‡≥Å ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤°‡≥Ü‡≤Ø‡≥Å‡≤§‡≥ç‡≤§‡≥Ä‡≤∞‡≤ø.",
            "email_warning": "‚ö†Ô∏è ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Æ‡≤æ‡≤®‡≥ç‡≤Ø‡≤µ‡≤æ‡≤¶ ‡≤á‡≤Æ‡≥á‡≤≤‡≥ç ‡≤µ‡≤ø‡≤≥‡≤æ‡≤∏‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤Æ‡≥Ç‡≤¶‡≤ø‡≤∏‡≤ø.",
            "health_alert": "üö® ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü",
            "common_disease": "‡≤π‡≥Ü‡≤ö‡≥ç‡≤ö‡≥Å ‡≤ï‡≤Ç‡≤°‡≥Å‡≤¨‡≤∞‡≥Å‡≤µ ‡≤∞‡≥ã‡≤ó:",
            "precautions_header": "üõ°Ô∏è ‡≤Æ‡≥Å‡≤®‡≥ç‡≤®‡≥Ü‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü ‡≤ï‡≥ç‡≤∞‡≤Æ‡≤ó‡≤≥‡≥Å",
            "trend_analysis": "üìä ‡≤∞‡≥ã‡≤ó ‡≤™‡≥ç‡≤∞‡≤µ‡≥É‡≤§‡≥ç‡≤§‡≤ø ‡≤µ‡≤ø‡≤∂‡≥ç‡≤≤‡≥á‡≤∑‡≤£‡≥Ü",
            "no_outbreak": "‚úÖ ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤™‡≥ç‡≤∞‡≤¶‡≥á‡≤∂‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤∞‡≥ã‡≤ó ‡≤π‡≤∞‡≤°‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü‡≤Ø ‡≤µ‡≤∞‡≤¶‡≤ø‡≤Ø‡≤æ‡≤ó‡≤ø‡≤≤‡≥ç‡≤≤.",
            "email_sent": "üìß ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü:",
            "email_failed": "‚ùå ‡≤á‡≤Æ‡≥á‡≤≤‡≥ç ‡≤ï‡≤≥‡≥Å‡≤π‡≤ø‡≤∏‡≤≤‡≥Å ‡≤µ‡≤ø‡≤´‡≤≤‡≤µ‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü:",
            "checking_alerts": "‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤∞‡≤ø‡≤∂‡≥Ä‡≤≤‡≤ø‡≤∏‡≤≤‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü...",
            "high_risk_alert": "‚ö†Ô∏è ‡≤Ö‡≤ß‡≤ø‡≤ï-‡≤Ö‡≤™‡≤æ‡≤Ø‡≤¶ ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü!",
            "high_risk_message": "‡≤®‡≤≤‡≥ç‡≤≤‡≤ø ‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞‡≤µ‡≤æ‡≤¶ ‡≤π‡≤∞‡≤°‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü ‡≤ï‡≤Ç‡≤°‡≥Å‡≤¨‡≤Ç‡≤¶‡≤ø‡≤¶‡≥Ü",
            "take_precautions": "‡≤Æ‡≥Å‡≤®‡≥ç‡≤®‡≥Ü‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≥Ü‡≤ó‡≥Ü‡≤¶‡≥Å‡≤ï‡≥ä‡≤≥‡≥ç‡≤≥‡≤ø!"
        }
    }

    # Disease translations
    disease_translations = {
        "English": {
            "Dengue": "Dengue",
            "Malaria": "Malaria",
            "COVID-19": "COVID-19",
            "Cholera": "Cholera",
            "Swine Flu": "Swine Flu"
        },
        "‡≤ï‡≤®‡≥ç‡≤®‡≤°": {  # Kannada
            "Dengue": "‡≤°‡≥Ü‡≤Ç‡≤ó‡≥ç‡≤Ø‡≥Ç",
            "Malaria": "‡≤Æ‡≤≤‡≥á‡≤∞‡≤ø‡≤Ø‡≤æ",
            "COVID-19": "‡≤ï‡≥ã‡≤µ‡≤ø‡≤°‡≥ç-19",
            "Cholera": "‡≤ï‡≤æ‡≤≤‡≤∞‡≤æ",
            "Swine Flu": "‡≤π‡≤Ç‡≤¶‡≤ø ‡≤ú‡≥ç‡≤µ‡≤∞"
        }
    }

    # Precautions translations
    precautions_translations = {
        "English": {
            "Dengue": "Use mosquito repellents, avoid stagnant water, and sleep under mosquito nets.",
            "Malaria": "Use insecticide-treated nets, wear long sleeves, and eliminate standing water.",
            "COVID-19": "Wear masks, sanitize hands regularly, and avoid crowded areas.",
            "Cholera": "Drink boiled water, maintain hygiene, and avoid contaminated food.",
            "Swine Flu": "Cover mouth while sneezing, avoid close contact with infected people, and get vaccinated.",
            "default": "Follow general hygiene and stay updated on local health advisories."
        },
        "‡≤ï‡≤®‡≥ç‡≤®‡≤°": {  # Kannada
            "Dengue": "‡≤∏‡≥ä‡≤≥‡≥ç‡≤≥‡≥Ü ‡≤®‡≤ø‡≤µ‡≤æ‡≤∞‡≤ï‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤¨‡≤≥‡≤∏‡≤ø, ‡≤®‡≤ø‡≤Ç‡≤§ ‡≤®‡≥Ä‡≤∞‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≤™‡≥ç‡≤™‡≤ø‡≤∏‡≤ø, ‡≤Æ‡≤§‡≥ç‡≤§‡≥Å ‡≤∏‡≥ä‡≤≥‡≥ç‡≤≥‡≥Ü ‡≤¨‡≤≤‡≥Ü‡≤ó‡≤≥ ‡≤Ö‡≤°‡≤ø‡≤Ø‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Æ‡≤≤‡≤ó‡≤ø.",
            "Malaria": "‡≤ï‡≥Ä‡≤ü‡≤®‡≤æ‡≤∂‡≤ï ‡≤ö‡≤ø‡≤ï‡≤ø‡≤§‡≥ç‡≤∏‡≥Ü ‡≤Æ‡≤æ‡≤°‡≤ø‡≤¶ ‡≤¨‡≤≤‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤¨‡≤≥‡≤∏‡≤ø, ‡≤¶‡≥Ä‡≤∞‡≥ç‡≤ò ‡≤§‡≥ã‡≤≥‡≥Å‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤ß‡≤∞‡≤ø‡≤∏‡≤ø, ‡≤Æ‡≤§‡≥ç‡≤§‡≥Å ‡≤®‡≤ø‡≤Ç‡≤§‡≤ø‡≤∞‡≥Å‡≤µ ‡≤®‡≥Ä‡≤∞‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≥Ü‡≤ó‡≥Ü‡≤¶‡≥Å‡≤π‡≤æ‡≤ï‡≤ø.",
            "COVID-19": "‡≤Æ‡≥Å‡≤ñ‡≤ó‡≤µ‡≤∏‡≥Å‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤ß‡≤∞‡≤ø‡≤∏‡≤ø, ‡≤ï‡≥à‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤®‡≤ø‡≤Ø‡≤Æ‡≤ø‡≤§‡≤µ‡≤æ‡≤ó‡≤ø ‡≤∏‡≥ç‡≤µ‡≤ö‡≥ç‡≤õ‡≤ó‡≥ä‡≤≥‡≤ø‡≤∏‡≤ø, ‡≤Æ‡≤§‡≥ç‡≤§‡≥Å ‡≤ú‡≤®‡≤¶‡≤ü‡≥ç‡≤ü‡≤£‡≥Ü‡≤Ø ‡≤™‡≥ç‡≤∞‡≤¶‡≥á‡≤∂‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≤™‡≥ç‡≤™‡≤ø‡≤∏‡≤ø.",
            "Cholera": "‡≤ï‡≥Å‡≤¶‡≤ø‡≤∏‡≤ø‡≤¶ ‡≤®‡≥Ä‡≤∞‡≤®‡≥ç‡≤®‡≥Å ‡≤ï‡≥Å‡≤°‡≤ø‡≤Ø‡≤ø‡≤∞‡≤ø, ‡≤®‡≥à‡≤∞‡≥ç‡≤Æ‡≤≤‡≥ç‡≤Ø‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤ï‡≤æ‡≤™‡≤æ‡≤°‡≤ø‡≤ï‡≥ä‡≤≥‡≥ç‡≤≥‡≤ø, ‡≤Æ‡≤§‡≥ç‡≤§‡≥Å ‡≤ï‡≤≤‡≥Å‡≤∑‡≤ø‡≤§ ‡≤Ü‡≤π‡≤æ‡≤∞‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≤™‡≥ç‡≤™‡≤ø‡≤∏‡≤ø.",
            "Swine Flu": "‡≤∏‡≥Ä‡≤®‡≥Å‡≤µ‡≤æ‡≤ó ‡≤¨‡≤æ‡≤Ø‡≤ø ‡≤Æ‡≥Å‡≤ö‡≥ç‡≤ö‡≤ø, ‡≤∏‡≥ã‡≤Ç‡≤ï‡≤ø‡≤§ ‡≤ú‡≤®‡≤∞‡≥ä‡≤Ç‡≤¶‡≤ø‡≤ó‡≥Ü ‡≤®‡≤ø‡≤ï‡≤ü ‡≤∏‡≤Ç‡≤™‡≤∞‡≥ç‡≤ï‡≤µ‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≤™‡≥ç‡≤™‡≤ø‡≤∏‡≤ø, ‡≤Æ‡≤§‡≥ç‡≤§‡≥Å ‡≤≤‡≤∏‡≤ø‡≤ï‡≥Ü ‡≤π‡≤æ‡≤ï‡≤ø‡≤∏‡≤ø‡≤ï‡≥ä‡≤≥‡≥ç‡≤≥‡≤ø.",
            "default": "‡≤∏‡≤æ‡≤Æ‡≤æ‡≤®‡≥ç‡≤Ø ‡≤∏‡≥ç‡≤µ‡≤ö‡≥ç‡≤õ‡≤§‡≥Ü‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤Ö‡≤®‡≥Å‡≤∏‡≤∞‡≤ø‡≤∏‡≤ø ‡≤Æ‡≤§‡≥ç‡≤§‡≥Å ‡≤∏‡≥ç‡≤•‡≤≥‡≥Ä‡≤Ø ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤∏‡≤≤‡≤π‡≥Ü‡≤ó‡≤≥ ‡≤¨‡≤ó‡≥ç‡≤ó‡≥Ü ‡≤®‡≤µ‡≥Ä‡≤ï‡≤∞‡≤ø‡≤∏‡≤ø‡≤¶ ‡≤Æ‡≤æ‡≤π‡≤ø‡≤§‡≤ø‡≤Ø‡≤®‡≥ç‡≤®‡≥Å ‡≤™‡≤°‡≥Ü‡≤Ø‡≤ø‡≤∞‡≤ø."
        }
    }

    # Column translations for DataFrame display
    column_translations = {
        "English": {
            "Disease": "Disease",
            "Reported Cases": "Reported Cases",
            "Severity": "Severity",
            "Date": "Date",
            "High": "High",
            "Medium": "Medium",
            "Low": "Low"
        },
        "‡≤ï‡≤®‡≥ç‡≤®‡≤°": {
            "Disease": "‡≤∞‡≥ã‡≤ó",
            "Reported Cases": "‡≤µ‡≤∞‡≤¶‡≤ø‡≤Ø‡≤æ‡≤¶ ‡≤™‡≥ç‡≤∞‡≤ï‡≤∞‡≤£‡≤ó‡≤≥‡≥Å",
            "Severity": "‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞‡≤§‡≥Ü",
            "Date": "‡≤¶‡≤ø‡≤®‡≤æ‡≤Ç‡≤ï",
            "High": "‡≤Ö‡≤ß‡≤ø‡≤ï",
            "Medium": "‡≤Æ‡≤ß‡≥ç‡≤Ø‡≤Æ",
            "Low": "‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü"
        }
    }

    SUBSCRIBERS_FILE = "subscribers.csv"
    if not os.path.exists(SUBSCRIBERS_FILE):
        pd.DataFrame(columns=["Email", "Location"]).to_csv(SUBSCRIBERS_FILE, index=False)

    # Load subscribers
    subscribers_df = pd.read_csv(SUBSCRIBERS_FILE)

    # Streamlit UI
    st.sidebar.title("‚öôÔ∏è Settings")
    language = st.sidebar.selectbox("Language / ‡≤≠‡≤æ‡≤∑‡≥Ü", ["English", "‡≤ï‡≤®‡≥ç‡≤®‡≤°"])
    t = translations[language]  # Get translations for selected language

    # Title and intro
    st.title(t["title"])
    st.markdown(t["subtitle"])

    # File uploader
    uploaded_file = st.file_uploader(t["upload_text"], type=["csv"])



    # Translate disease names in dataframe if needed
    if language == "‡≤ï‡≤®‡≥ç‡≤®‡≤°":
        df = df.copy()
        df["Disease"] = df["Disease"].apply(lambda x: disease_translations["‡≤ï‡≤®‡≥ç‡≤®‡≤°"].get(x, x))
        df["Severity"] = df["Severity"].replace({"High": "‡≤Ö‡≤ß‡≤ø‡≤ï", "Medium": "‡≤Æ‡≤ß‡≥ç‡≤Ø‡≤Æ", "Low": "‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü"})

    # Subscription File
    SUBSCRIBERS_FILE = "subscribers.csv"
    if not os.path.exists(SUBSCRIBERS_FILE):
        pd.DataFrame(columns=["Email", "Location"]).to_csv(SUBSCRIBERS_FILE, index=False)

    # Load subscribers
    subscribers_df = pd.read_csv(SUBSCRIBERS_FILE)

    # User selects current location
    selected_location = st.selectbox(t["select_location"], df["Locality"].unique())
    location_data = df[df["Locality"] == selected_location]

    # Email Subscription Feature
    st.subheader(t["subscribe_header"])
    user_email = st.text_input(t["email_input"])
    if st.button(t["subscribe_button"]):
        if user_email:
            new_subscriber = pd.DataFrame([[user_email, selected_location]], columns=["Email", "Location"])
            new_subscriber.to_csv(SUBSCRIBERS_FILE, mode='a', header=False, index=False)
            st.success(t["subscription_success"])
        else:
            st.warning(t["email_warning"])

    # Function to Send Email Alert (with language support)
    def send_email_alert(recipient_email, location, disease, lang="English"):
        sender_email = "vineethb11@gmail.com"  # Replace with your email
        sender_password = "mjxh vqsi vzoz hijo"  # Replace with your email password
        
        # Translate disease name for email subject
        disease_translated = disease_translations[lang].get(disease, disease) if disease in disease_translations.get("English", {}) else disease
        
        if lang == "English":
            subject = f"‚ö†Ô∏è Health Alert: {disease_translated} Outbreak in {location}"
            body = f"Dear User,\n\nA severe outbreak of {disease_translated} has been detected in {location}. Please take necessary precautions.\n\nStay Safe,\nBangalore Health Alert System"
        else:  # Kannada
            subject = f"‚ö†Ô∏è ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü: {location} ‡≤®‡≤≤‡≥ç‡≤≤‡≤ø {disease_translated} ‡≤π‡≤∞‡≤°‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü"
            body = f"‡≤™‡≥ç‡≤∞‡≤ø‡≤Ø ‡≤¨‡≤≥‡≤ï‡≥Ü‡≤¶‡≤æ‡≤∞‡≤∞‡≥á,\n\n{location} ‡≤®‡≤≤‡≥ç‡≤≤‡≤ø {disease_translated} ‡≤® ‡≤§‡≥Ä‡≤µ‡≥ç‡≤∞ ‡≤π‡≤∞‡≤°‡≥Å‡≤µ‡≤ø‡≤ï‡≥Ü‡≤Ø‡≥Å ‡≤™‡≤§‡≥ç‡≤§‡≥Ü‡≤Ø‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤Ö‡≤ó‡≤§‡≥ç‡≤Ø ‡≤Æ‡≥Å‡≤®‡≥ç‡≤®‡≥Ü‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü‡≤ó‡≤≥‡≤®‡≥ç‡≤®‡≥Å ‡≤§‡≥Ü‡≤ó‡≥Ü‡≤¶‡≥Å‡≤ï‡≥ä‡≤≥‡≥ç‡≤≥‡≤ø.\n\n‡≤∏‡≥Å‡≤∞‡≤ï‡≥ç‡≤∑‡≤ø‡≤§‡≤µ‡≤æ‡≤ó‡≤ø‡≤∞‡≤ø,\n‡≤¨‡≥Ü‡≤Ç‡≤ó‡≤≥‡≥Ç‡≤∞‡≥Å ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤é‡≤ö‡≥ç‡≤ö‡≤∞‡≤ø‡≤ï‡≥Ü ‡≤µ‡≥ç‡≤Ø‡≤µ‡≤∏‡≥ç‡≤•‡≥Ü"
        
        msg = MIMEMultipart()
        msg["From"] = sender_email
        msg["To"] = recipient_email
        msg["Subject"] = subject
        msg.attach(MIMEText(body, "plain"))
        
        try:
            server = smtplib.SMTP("smtp.gmail.com", 587)
            server.starttls()
            server.login(sender_email, sender_password)
            server.sendmail(sender_email, recipient_email, msg.as_string())
            server.quit()
            st.success(f"{t['email_sent']} {recipient_email}!")
        except Exception as e:
            st.error(f"{t['email_failed']} {str(e)}")

    if not location_data.empty:
        # Expand the date range to last 5 months for better outbreak detection
        latest_data = location_data[location_data["Date"] >= (pd.to_datetime("today") - pd.Timedelta(days=150)).strftime("%Y-%m-%d")]
        
        if not latest_data.empty:
            most_common_disease = latest_data["Disease"].value_counts().idxmax()
        else:
            most_common_disease = location_data["Disease"].value_counts().idxmax()
        
        # Get original disease name before translation for system use
        original_disease_name = most_common_disease
        if language == "‡≤ï‡≤®‡≥ç‡≤®‡≤°":
            # Reverse lookup to get English disease name
            for eng_name, kan_name in disease_translations["‡≤ï‡≤®‡≥ç‡≤®‡≤°"].items():
                if kan_name == most_common_disease:
                    original_disease_name = eng_name
                    break
        
        st.subheader(f"{t['health_alert']} {selected_location}")
        st.markdown(f"**{t['common_disease']}** {most_common_disease}")
        
        # Display data with translated column names if in Kannada
        if language == "‡≤ï‡≤®‡≥ç‡≤®‡≤°":
            display_df = location_data.copy()
            display_df.columns = [column_translations["‡≤ï‡≤®‡≥ç‡≤®‡≤°"].get(col, col) for col in display_df.columns]
            st.write(display_df[[column_translations["‡≤ï‡≤®‡≥ç‡≤®‡≤°"]["Disease"], 
                                column_translations["‡≤ï‡≤®‡≥ç‡≤®‡≤°"]["Reported Cases"], 
                                column_translations["‡≤ï‡≤®‡≥ç‡≤®‡≤°"]["Severity"], 
                                column_translations["‡≤ï‡≤®‡≥ç‡≤®‡≤°"]["Date"]]])
        else:
            st.write(location_data[["Disease", "Reported Cases", "Severity", "Date"]])
        
        # Show Map with Red Boundary instead of markers
        map_center = [location_data.iloc[0]["Latitude"], location_data.iloc[0]["Longitude"]]
        m = folium.Map(location=map_center, zoom_start=14)
        folium.Circle(
            location=map_center,
            radius=1000,  # Radius in meters
            color="red",
            fill=True,
            fill_color="red",
            fill_opacity=0.4,
            popup=f"{selected_location} - {most_common_disease} Alert"
        ).add_to(m)
        
        folium_static(m)
        
        # Real-Time Notification if High-Risk Area
        severity_col = "Severity"
        severity_check = "High"
        if language == "‡≤ï‡≤®‡≥ç‡≤®‡≤°":
            severity_check = "‡≤Ö‡≤ß‡≤ø‡≤ï"
        
        if latest_data[severity_col].str.contains(severity_check).any():
            with st.spinner(t["checking_alerts"]):
                time.sleep(2)
            st.error(f"{t['high_risk_alert']} {selected_location} {t['high_risk_message']} {most_common_disease}. {t['take_precautions']}")
            
            # Send Email Alert to Users Subscribed to This Location
            affected_users = subscribers_df[subscribers_df["Location"] == selected_location]["Email"]
            for email in affected_users:
                send_email_alert(email, selected_location, original_disease_name, language)
        
        # Health suggestions and precautions based on language
        st.subheader(t["precautions_header"])
        st.markdown(precautions_translations[language].get(original_disease_name, precautions_translations[language]["default"]))
        
        # Data Analysis: Bar plot for cases over time
        st.subheader(t["trend_analysis"])
        
        # Create a copy for plotting to prevent modifying the original
        plot_data = latest_data.copy()
        
        # Customize plot based on language
        if language == "‡≤ï‡≤®‡≥ç‡≤®‡≤°":
            plot_title = f"{selected_location} ‡≤®‡≤≤‡≥ç‡≤≤‡≤ø ‡≤∞‡≥ã‡≤ó‡≤ó‡≤≥ ‡≤™‡≥ç‡≤∞‡≤µ‡≥É‡≤§‡≥ç‡≤§‡≤ø‡≤ó‡≤≥‡≥Å (‡≤ï‡≤≥‡≥Ü‡≤¶ 5 ‡≤§‡≤ø‡≤Ç‡≤ó‡≤≥‡≥Å‡≤ó‡≤≥‡≥Å)"
            x_label = "‡≤¶‡≤ø‡≤®‡≤æ‡≤Ç‡≤ï"
            y_label = "‡≤µ‡≤∞‡≤¶‡≤ø‡≤Ø‡≤æ‡≤¶ ‡≤™‡≥ç‡≤∞‡≤ï‡≤∞‡≤£‡≤ó‡≤≥‡≥Å"
        else:
            plot_title = f"Disease Trends in {selected_location} (Last 5 Months)"
            x_label = "Date"
            y_label = "Reported Cases"
        
        fig = px.bar(
            plot_data, 
            x="Date", 
            y="Reported Cases", 
            color="Disease", 
            title=plot_title
        )
        
        fig.update_layout(
            xaxis_title=x_label,
            yaxis_title=y_label
        )
        
        st.plotly_chart(fig)
    else:
        st.success(t["no_outbreak"])
        

elif user_type == "Admin":
    
    admin_key = st.sidebar.text_input("Enter Admin Key:", type="password")
    if admin_key != ADMIN_KEY:
        st.sidebar.warning("‚ö†Ô∏è Incorrect Key! Access Denied.")
        st.stop()
    else:
        st.sidebar.success("‚úÖ Access Granted. Viewing Admin Panel.")

        # Admin Dashboard
        st.title("üìä Admin Dashboard - Monitoring & Insights")
        
        # Full Dataset
        st.subheader("üìÇ Full Dataset Overview")
        st.dataframe(df)
        
        # Disease Frequency Analysis
        st.subheader("üìà Disease Frequency Analysis")
        disease_counts = df["Disease"].value_counts()
        st.bar_chart(disease_counts)
        
        # Severity Distribution Analysis
        st.subheader("‚ö†Ô∏è Severity Distribution")
        severity_counts = df["Severity"].value_counts()
        st.bar_chart(severity_counts)
        
        # Cases Over Time
        st.subheader("üìÜ Cases Over Time")
        fig = px.line(df, x="Date", y="Reported Cases", color="Disease", title="Disease Cases Over Time")
        st.plotly_chart(fig)
        
        # Most Affected Areas
        
        
        # View Subscribers List
        st.subheader("üìú Subscribers List")
        subscribers_df = pd.read_csv("subscribers.csv")
        st.dataframe(subscribers_df)
        
        
        # Stop execution to prevent access to user UI
        st.stop()
elif user_type == "Chat bots":

    # Configure Gemini API
    genai.configure(api_key="************************")
    generation_config = {"temperature": 0.9, "top_p": 1, "top_k": 1, "max_output_tokens": 2048}
    model = genai.GenerativeModel("gemini-2.0-flash", generation_config=generation_config)

    # Database and CSV paths
    db_path = r'vector_database.sqlite3'
    csv_file_path = "chat_history.csv"

    # Ensure chat history CSV exists
    if not os.path.exists(csv_file_path):
        with open(csv_file_path, mode="w", newline="", encoding="utf-8") as file:
            writer = csv.writer(file)
            writer.writerow(["User Query", "Bot Response"])

    def log_chat_to_csv(user_query, bot_response):
        """Append each query-response pair to a CSV file."""
        with open(csv_file_path, mode="a", newline="", encoding="utf-8") as file:
            writer = csv.writer(file)
            writer.writerow([user_query, bot_response])

    def generate_queries_gemini(original_query):
        """Generate refined queries using Gemini API."""
        content_prompts = [f"Generate a single refined query related to: {original_query} with a proper description in 4-5 lines."]
        response = model.generate_content(content_prompts)
        return response.text.strip()

    def vector_search(query):
        """Perform vector similarity search in SQLite database."""
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT filename, vector FROM documents")
            rows = cursor.fetchall()
            conn.close()
        except sqlite3.Error as e:
            print(f"SQLite error: {e}")
            return {}

        query_vector = np.random.rand(1, 384).astype(np.float32)
        scores = {}
        for filename, vector_blob in rows:
            vector = np.frombuffer(vector_blob, dtype=np.float32).reshape(1, -1)
            similarity_score = cosine_similarity(query_vector, vector)[0][0]
            scores[filename] = similarity_score

        return {doc: score for doc, score in sorted(scores.items(), key=lambda x: x[1], reverse=True) if score > 0}

    def reciprocal_rank_fusion(search_results_dict, k=60):
        """Perform Reciprocal Rank Fusion (RRF) for search results."""
        fused_scores = {}
        for query, doc_scores in search_results_dict.items():
            for rank, (doc, score) in enumerate(sorted(doc_scores.items(), key=lambda x: x[1], reverse=True)):
                fused_scores[doc] = fused_scores.get(doc, 0) + 1 / (rank + k)
        return {doc: score for doc, score in sorted(fused_scores.items(), key=lambda x: x[1], reverse=True)}

    def generate_content_google(reranked_results, queries):
        """Summarize key information from retrieved documents."""
        
        prompt = (f"Imagine you are a doctor, and a patient is describing their symptoms to you. "
                f"Show empathy for their suffering, analyze the symptoms carefully, and determine "
                f"the most likely disease they might have. Then, recommend appropriate medicines. "
                f"Make sure to format the response in separate lines as follows: \n"
                f"**Name of the disease:** - [Predicted Disease]\n"
                f"**Prescription:** - [Suggested Medicines]\n"
                f"Also, add a disclaimer advising the patient to consult a doctor for more information.\n"
                f"Symptoms: {queries}. Consider these relevant documents: {list(reranked_results.keys())}.")
        
        response = model.generate_content([prompt])
        
        # Clean and structure response properly
        response_text = response.text.strip()
        
        return response_text  # Ensure the full formatted response is returned

    def translate_text(text, target_language):
        """Translate text into the selected language."""
        try:
            return GoogleTranslator(source='auto', target=target_language).translate(text)
        except Exception as e:
            print(f"Translation error: {e}")
            return text  

    def chatbot_interface(message, chat_history, language):
        """Handle user input and generate chatbot response."""
        if chat_history is None:
            chat_history = []  
        
        chat_history.append({"role": "user", "content": message})
        generated_queries = generate_queries_gemini(message)
        all_results = {query: vector_search(query) for query in generated_queries.split('\n')}
        reranked_results = reciprocal_rank_fusion(all_results)
        response = generate_content_google(reranked_results, generated_queries)
        
        if language == "Hindi": 
            response = translate_text(response, "hi")
        elif language == "Tamil":  
            response = translate_text(response, "ta")
        log_chat_to_csv(message, response)
        chat_history.append({"role": "assistant", "content": response})
        return chat_history, chat_history

    # Streamlit UI
    st.title("RAG-Gemini Chatbot")
    user_input = st.text_input("Enter your query:")
    language = st.selectbox("Select Language", ["English", "Hindi", "Tamil"])

    if "chat_history" not in st.session_state:
        st.session_state.chat_history = []

    if st.button("Submit"):
        st.session_state.chat_history, displayed_chat = chatbot_interface(user_input, st.session_state.chat_history, language)

        for chat in displayed_chat:
            role = "User" if chat["role"] == "user" else "Bot"
            st.text(f"{role}: {chat['content']}")

# Subscription File






